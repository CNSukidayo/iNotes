# 目录:  
1.SQL执行过程  
2.事务  
3.锁  
4.日志  
5.索引  


## 2.事务  
**目录:**  
2.1 事务的四大特性  
2.2 脏读、幻读、不可重复读  
2.3 事务的隔离级别  
2.4 MVCC   

### 2.1 事务的四大特性  
**解释:** 事务是MySQL执行的最小单元,一个事务内的操作要么全部成功要么全不成功.  

1.事务的四大特性ACID
* A(Atomicity):原子性 一个事务中的所有操作要么全都完成要么全都不完成. 
* C(Consistency):一致性 不管事务是否成功,数据库的状态是一致性的.  
* I(Isolation):隔离性 多个事务可以互相隔离,一个事务的操作不会影响到另一个事务.  
* D(Durability):持久性 事务处理结束后,落盘存储;对数据的修改是永久的.

2.InnoDB通过什么技术来保障这四个特性的?
* 原子性通过undo log(撤销日志)来保障
* 持久性通过redo log(重做日志)来保障
* 隔离性通过MVCC或锁机制来保障
* 一致性是通过原子性+隔离性+持久性得到保障的  
  原子性+隔离性+持久性=>一致性

### 2.2 脏读、幻读、不可重复读  
* 脏读:一个事务读到了另一个事务还未提交的数据  
* 不可重复读:一个事务(同一条SQL)前后两次读取到的数据不一致  
* 幻读:一个事务(同一条SQL)前后两次读取到的数据量不一致  

脏读:事务A读取到事务B未提交的数据  
不可重复度&幻读:事务A读取到事务B已提交的数据  

### 2.3 事务的隔离级别
1.事务的隔离级别是针对连接(session)而言的(而不是数据库)  

2.数据库的四种隔离级别  
|     隔离级别     | 脏读  | 不可重复读 | 幻读  |
| :--------------: | :---: | :--------: | :---: |
| READ-UNCOMMITTED |   √   |     √      |   √   |
|  READ-COMMITTED  |   x   |     √      |   √   |
| REPEATABLE-READ  |   x   |     x      |   √   |
|   SERIALIZABLE   |   x   |     x      |   x   |

*备注:打钩代表可能出现的情况*

* READ-UNCOMMITTED:一个事务可以读取到另一个事务未提交的数据
* READ-COMMITTED:一个事务只能读取到另一个事务已提交的数据  
* REPEATABLE-READ:一个事务读取的数据内容和它刚开始启动时读取对应数据的内容是一致的(从这个解释看出是不放幻读的)  
* SERIALIZABLE:事务执行时会对记录加上读/写锁,事务之间串行化完成  

3.数据库的默认隔离级别<font color="#00FF00">REPEATABLE-READ</font>

4.MySQL的InnoDB存储引擎的REPEATABLE-READ隔离级别可以很大程度避免幻读,所以SERIALIZABLE的这种隔离级别不常用.  

5.解决幻读的方法  
* **快照读:** 通过MVCC的版本号来保障,当前事务只会读取不大于事务开始时版本号的数据,所以后序插入的数据由于版本号过高就不会被当前事务读取到.它的SQL语句形式是(select ... from);也就是说REPEATABLE-READ隔离级别默认就是通过MVCC来实现的.  
* **当前读:** 这里要结合MySQL**行**锁那一章,通过记录锁+间隙锁的方式解决了幻读;它的SQL语句的形式是:(select ... for update)当执行这段语句的时候,会加上next-key lock ,如果有其它事务在next-key lock范围内插入数据,那么这条插入语句就会被阻塞,从而避免了幻读问题. 
* ~~使用SERIALIZABLE隔离级别(划掉是因为效率不高,用是可以用的)~~

### 2.4 MVCC  
**解释:** MVCC称为多版本并发控制;它是一种概念,具体的实现手段通过Read View来实现.  
**解释:** Read View本质就是一个数据结构,如果是通过Read View来实现的话,每个事务都会有一个Read View对象.通过Read View对象可以实现**可重复读**、**读已提交**  

Read View的数据结构:  
```c
class ReadView {
private:
  trx_id_t m_low_limit_id;      /* 大于等于这个 ID 的事务均不可见 */

  trx_id_t m_up_limit_id;       /* 小于这个 ID 的事务均可见 */

  trx_id_t m_creator_trx_id;    /* 创建该 Read View 的事务ID */

  trx_id_t m_low_limit_no;      /* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */

  ids_t m_ids;                  /* 创建 Read View 时的活跃事务列表 */

  m_closed;                     /* 标记 Read View 是否 close */
}
```
**属性解释:**  
|      属性      |                                 解释                                  |
| :------------: | :-------------------------------------------------------------------: |
| creator_trx_id |                       创建该Read View的事务的id                       |
|     m_ids      | 创建该Read View时当前数据库还有哪些事务没有提交的id列表(包含当前事务) |
|   min_trx_id   |   创建该Read View时未提交的事务的最小id(是从m_ids集合中选出的结果)    |
|    max_trx     |                    当前数据库应该给下一个事务的id                     |

**聚簇索引:**  
此外还需要了解聚簇索引的两个隐藏列
* trx_id 用于存储上一个修改该数据的事务的id
* roll_pointer 回滚指针每次对某条聚簇索引记录进行改动时,都会把旧版本的记录写入到undo日志中,然后这个隐藏列是个指针,指向每一个旧版本记录,于是就可以通过它找到修改前的记录.

1.接下来就是当前事务要去更新一条记录了:  
由于每个事务都会携带Read View对象;所以准备开始比较了  

* 如果数据隐藏列的trx_id值小于min_trx_id,则该记录对当前事务是可见的;因为现在的记录是创建当前事务之前的事务所修改的.  
* 如果trx_id值大于max_trx,则该记录对当前事务是不可见的;因为现在的记录是在当前事务后的事务中修改的.  
* 如果trx_id值在m_ids之中,则该记录对当前事务是不可见的;因为现在的记录是由比当前事务创建地更早的事务所修改的.  
* 如果trx_id值不在m_ids之中,则该记录对当前事务是可见的;因为现在的记录是在当前事务创建之前就已经提交了的.

2.区别  
**区别:** Read View可以实现可重复读和读已提交;它们的区别在于创建Read View的时机不同,**读已提交**是事务的每个语句执行之前重新生成一个Read View.**可重复读**是在事务启动时创建一个Read View并且在整个事务都复用这一个Read View.

3.多版本控制  
聚簇索引那边提到的**roll_pointer**,实际上就是一个链表指针;MVCC是真的会对一条记录组织许多版本,每条记录的隐含列roll_pointer都**指向**前一个版本的数据.

4.可重复读是如何工作的  

**参考:**[可重复读是如何工作的?](https://www.xiaolincoding.com/mysql/transaction/mvcc.html#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84)  
5.读已提交是如何工作的  
**参考:**[读已提交是如何工作的?](https://www.xiaolincoding.com/mysql/transaction/mvcc.html#%E8%AF%BB%E6%8F%90%E4%BA%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84)  

6.REPEATABLE-READ隔离级别真的解决幻读了吗?  
**解释:** 之前说过REPEATABLE-READ隔离级别只是很大程度上避免了 幻读,并没有完全解决.  
之前已经解释过快照读是如何避免幻读的,现在介绍<font color="#00FF00">当前读</font>是如何避免幻读的.  

[MySQL可重复读隔离级别,完全解决幻读了吗?](https://xiaolincoding.com/mysql/transaction/phantom.html#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%91%E7%94%9F%E5%B9%BB%E8%AF%BB%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%9C%BA%E6%99%AF)

**小结:** 要避免特殊场景下发生幻读,就是尽量在开启事务之后马上执行`select ... for update`语句,利用next-key lock的间隙锁锁住这部分记录.  


## 3.锁
**目录:**  
3.1 锁的分类(包括读锁、写锁)  
3.2 表级锁  
3.3 行级锁  
3.4 行级锁加锁时机  


### 3.1 锁的分类  
**简介:** 想要学好MySQL的锁,必须先了解锁的分类.从锁的粒度上来说一共分为三种锁:全局锁、表锁、行锁  
*提示:当然了只有innodb存储引擎支持行锁;也只有innodb引擎支持事务.*  

**全局锁:**  内容比较少也放到这里面来讲  
`flush tables with read lock` 开启全局锁  
`unlock tables` 释放全局锁;如果会话断开也会释放全局锁  
当使用全局锁之后,数据库就处于只读的状态了,此时如果对表中数据进行修改,如insert、update、delete或者对表结构进行修改,如alter table、drop table就会被**阻塞**.

**应用场景:** <font color="#FFC800">备份数据库</font>;但不推荐这种方式,可以使用REPEATABLE-READ的事务隔离级别来保障数据备份时的一致性.  

**表锁:** 表锁、元数据锁、意向锁、AUTO-INC锁  
*注意:* InnoDB和MyISAM引擎都支持表锁

**行锁:** 记录锁、间隙锁、Next-Key Lock  
*注意:* 行锁只有InnoDB引擎支持

**<font color="#FF00FF">读锁和写锁:</font>**  
不论是表锁还是行锁,根据它锁的特性又分为读锁和写锁  
读锁(S): 读锁也称之为共享锁  
写锁(X): 写锁也称之为排他锁  

|       |  S锁   |  X锁  |
| :---: | :----: | :---: |
|  S锁  | 不冲突 | 冲突  |
|  X锁  |  冲突  | 冲突  |

由于MVCC的存在,普通的查询是不会加锁的(快照读);只有**当前读**才会加锁.<font color="#00FF00">注意更新和删除是会加行锁的-写锁</font>  

### 3.2 表级锁
**分类:** 表锁、元数据锁、意向锁、AUTO-INC锁  

1.表锁  
**用法:**  
```sql
//表级别的共享锁，也就是读锁；
lock tables t_student read;

//表级别的独占锁，也就是写锁；
lock tables t_stuent write;
```

**特性:** 表锁不仅是对别的连接生效,对当前连接同样生效;如果当前连接加了表锁-读锁,接下来当前连接如果要对该表进行修改操作则当前连接阻塞.(如果连接/会话断开也会释放锁)    

2.元数据锁(MDL锁)  
**介绍:** 这也是数据库层面的,主要用户DML和DDL语句之间的互斥访问.MDL锁主要是保证当前用户对表执行CURD操作时,别的连接**修改表结构**.  

元数据锁同样也是表锁;但元数据锁的读锁和写锁概念就不太一样了  
* MDL读锁:对一张表进行CRUD操作时,加的是MDL读锁
* MDL写锁:对一张表结构进行变更时,加的是MDL写锁

|        | MDLS锁 | MDLX锁 |
| :----: | :----: | :----: |
| MDLS锁 | 不冲突 |  冲突  |
| MDLX锁 |  冲突  |  冲突  |


3.意向锁  
**作用:** 总结一句话就是,意向锁用于快速判断当前表中有没有行锁  
*提示:因为MyISAM引擎没有行锁,所以意向锁也是针对innodb引擎而言的*  

如果没有意向锁,那么在给表添加**表锁-写锁**的时候就需要判断表里面有没有记录已经加了**行锁-写锁**.因为表锁-写锁可以理解为给整张表的所有记录加了写锁,如果此时已经有某行记录加了读锁/或写锁再加表锁的话就冲突了.

所以每次加行锁之前都会先获取到表的意向锁(**意向锁是表级锁**),并且意向锁之间互不冲突.

**注意:** 意向锁是数据库自已维护的,用户无法手动操作意向锁;在为数据加行锁-读/写锁之前,innodb会先获取对应表的意向锁.

* 意向读锁(IS):事务对某行加读锁之前必须先获得意向读锁.  
* 意向写锁(IX):事务对某行加写锁之前必须先获得意向写锁.

|       |  IS锁  |  IX锁  |
| :---: | :----: | :----: |
| IS锁  | 不冲突 | 不冲突 |
| IX锁  | 不冲突 | 不冲突 |

**意向锁与表锁的互斥情况:**  
|       |  IS锁  | IX锁  |
| :---: | :----: | :---: |
|  S锁  | 不冲突 | 冲突  |
|  X锁  |  冲突  | 冲突  |

**结论:**
* 加表锁-读锁=>必须等表中所有的<font color="#FF00FF">意向写锁</font>释放=>必须等表中所有<font color="#FF00FF">行锁-写锁</font>释放.  
* 加表锁-写锁=>必须等表中所有<font color="#00FF00">意向读/写锁</font>释放=>必须等表中所有<font color="#00FF00">行锁-读/写锁</font>释放.  
* 加行锁-读锁=>必须获取<font color="#FF00FF">意向锁读锁</font>=>必须等<font color="#FF00FF">表锁-写锁</font>释放.  
* 加行锁-写锁=>必须获取<font color="#00FF00">意向锁写锁</font>=>必须等表中所有<font color="#00FF00">表锁-读/写锁</font>释放.  

4.AUTO-INC锁
**介绍:** 就是自增锁  

### 3.3 行级锁  
**分类:** 记录锁、间隙锁、Next-Key Lock  
*提示:只有innodb引擎支持行级锁*  
**注意:** 再次提示;由于MVCC的存在,普通的查询是不会加锁的(快照读);只有**当前读**才会加锁.<font color="#00FF00">注意更新和删除是会加行锁-写锁的</font>  
**释放锁的时机:** 事务提交就会释放锁;当然断开连接也会  

1.记录锁(Record Lock)  
**作用:** 只锁住一条记录  

2.间隙锁(Gap Lock)  
**作用:** 锁住一个范围的记录  
**注意:** 该锁只存在于可重复读的隔离级别中,目的是为了解决可重复读隔离级别下的幻读现象.  
**冲突性:** 间隙锁虽然存在读锁写锁,但是并没有什么区别,间隙锁之间是兼容的,即两个事务可以同时持有包含共同间隙范围的间隙锁,并不存在互斥关系,因为间隙锁的目的是防止插入幻影记录而提出的.  

3.临间锁(Next-Key Lock)  
**介绍:** Next-Key Lock = Record Lock + Gap Lock  
**冲突性:** 临间锁之间是冲突的,虽然间隙锁不冲突;但是记录锁之间是冲突的.  

### 3.4 行级锁加锁时机  
**目录:**  
3.4.1 什么SQL语句会导致加锁  
3.4.2 加什么类型的行锁  
3.4.3 唯一索引等值查询  
3.4.4 唯一索引范围查询  
3.4.5 非唯一索引等值查询  
3.4.6 非唯一索引范围查询  
3.4.7 没有加索引的查询  

#### 3.4.1 什么时候会加行锁  
1.首先对于普通查询innodb是不会加锁的;快照读是由MVCC来保障的.  
2.只有**当前读**即通过Next-Key Lock锁来实现时才会加行锁.  
```sql
-- 通过下面两种方式来显示地加锁
-- 共享锁
SELECT ... FOR SHARE;
-- 排他锁
SELECT ... FOR UPDATE;
```
3.update和delete操作会加行锁-写锁  

4.释放锁的时机:事务提交就会释放锁;当然断开连接也会

#### 3.4.2 加什么类型的行锁 
**行锁分类:** 记录锁、间隙锁、Next-Ket Lock  
**<font color="#FF00FF">在不同的隔离级别下,行锁的类型是不同的</font>**  
* 在读已提交的隔离级别下,加的行锁类型只会是记录锁
* 在可重复读隔离级别下,如果能加锁(就是不走MVCC,通过手动加锁的方式加锁)则加的是Next-Key Lock锁.
* Gap Lock间隙锁,该锁只存在于可重复读的隔离级别下.  

<font color="#00FF00">由于当前读是加锁的,所以当前读 读到的都是最新数据.</font>这是和MVCC最大的不同,因为别的事务没法对记录进行修改.   

1.锁加在什么上面  
<font color="#FF00FF">锁只加在聚簇索引上,如果加锁时用到了二级索引则会先在二级索引上加锁;然后在聚簇索引上加锁</font>

2.写在前面的总结性内容  
<font color="#00FF00">在可重复读的隔离环境下,锁是加在索引上的;加锁的基本单位是Next-Key Lock;但是在只加记录锁或间隙锁就能解决幻读的情况下,Next-Key Lock会退化为记录锁或间隙锁</font>  
*Tips:如果看不懂这句话,可以先看把这一节的所有知识点看完;因为这些是概括性的内容*  

3.查看加锁情况  
`select * from performance_schema.data_locks\G;`  
![加锁情况](resources/mysql/1.png)  
* LOCK_TYPE:锁类型
  * TABLE:表级锁
  * RECORD:行级锁(RECORD不是指记录锁)  
* LOCK_MODE:
  * IX:表级锁-意向锁-写锁
  * IS:表级锁-意向锁-读锁
  - - - 
  * X,REC_NOT_GAP:行级锁-记录锁-写锁
  * X,GAP:行级锁-间隙锁-写锁
  * X:行级锁-临间锁(Next-key Lock)-写锁

#### 3.4.3 唯一索引等值查询  
**测试环境:**  
接下来 3.4.3-3.4.6的测试都用到了这么一张表,它有一个主键id和一个普通索引age.还有一个无关紧要的name字段  

|  id   |  name  |  age  |
| :---: | :----: | :---: |
|   1   | 蔡徐坤 |  19   |
|   5   | 马嘉祺 |  21   |
|  10   | 林彦俊 |  22   |
|  15   | 黄明昊 |  20   |
|  20   | 张真源 |  39   |

**告知:**  
* 接下来的几种情况中都需要讨论,目标查询的记录是否在表中这种情况;所以就分为两种情况:目标记录在表中和不在表中  
* 唯一索引这里就是指用的索引是不是主键(而不是用的索引是不是唯一索引=>主键一定是唯一索引,但唯一索引不一定是主键)  
* 等值查询就是where后面是等于`=`;范围查询就是where后面用的是`>、<、>=、<=`  

1.唯一索引等值查询,目标记录在表中  
`select * from table where id = 1 for update` 能够查询到记录  
此时会给id=1的记录加上行锁-写锁-记录锁  

2.唯一索引等值查询,目标记录不在表中  
`select * from table where id = 2 for update` 不能查询到记录  
此时会给id = 1 到 5的记录加上行锁-间隙锁-写锁,即锁住(1,5)范围内的数据.  
为什么是(1,5)?  
首先由于记录2不在目标表中,所以会先从2往id更大的方向找记录;找到第一条记录为id=5;此时代表右边界就是5;接着从2向做找;找到第一条记录为1;此时代表左边界就是1.  

#### 3.4.4 唯一索引范围查询
**分类:** >、>=、<、<=  

**特性:** 唯一索引范围查询会对每一个扫描到的索引加Next-Key Lock锁;对索引加Next-Key Lock锁的意思就是用记录锁锁住当前记录(查询到的记录),用间隙锁锁住范围.  
<font color="#00FF00">间隙锁区间是左开右开(min,max);Next-Key Lock的区间是左开右闭(min,max]</font>

1.唯一索引范围查询-大于(>)  
`select * from table where id > 15 for update`  
* 此时会从15开始往右查询(往右查询就是指往id更大的方向查询),查到第一个记录为20;此时会在索引20加上Next-Key Lock-写锁锁住(15,20]范围的记录.  
* 接着再从索引20往右查询,一直到+∞;此时Next-key Lock写锁锁住(20,+∞]的记录.

**注意:** 大于查询对记录15本身是无关紧要的;因为不管你记录15是否存在;id>15都管辖不到记录15本身;所以记录15要杀要剐随便.  

2.唯一索引范围查询-大于等于(>=)-目标记录在表中  
`select * from table where id >= 15 for update`  
* 依旧先从记录15开始查询;发现记录15存在于表中,所以此时会将记录15加上行锁-记录锁-写锁  
* 接着从15开始往右查询,查到的第一个记录为20;此时会在索引20加上Next-Key Lock-写锁锁住(15,20]范围的记录.  
* 接着再从索引20往右查询,一直到+∞;此时Next-key Lock写锁锁住(20,+∞]的记录.

**注意:** <font color="#00FF00">如果目标记录不在表中</font>,则加锁的情况和大于查询的情况一模一样.而且正是因为Next-Key Lock是<font color="#00FF00">左开右闭</font>的;而现在15又在id>=15的管辖范围内,为了解决Next-Key Lock不能锁住左边的,那就再加一个记录锁嘛!  

3.唯一索引范围查询-小于(<)-目标记录不在表中  
`select * from table where id < 6 for update`  
**查询结果:** 查询到记录1和记录5,并且记录6不在表中  
**技巧:** 不管是大于还是小于,都是从左边开始扫描的;如果是大于查询就从where后面的id扫描到+∞;如果是小于查询就从-∞扫描到where后面的id.  
* 从-∞开始往右扫描,扫描到的第一条记录为1;并且1小于6;此时给(-∞,1]加上Next-Key Lock
* 从1开始往右扫描,扫描的第一条记录为5;并且5小于6;此时给(-∞,5]加上Next-Key Lock
* 从5开始往右扫描,扫描的第一条记录为10;但是10<font color="#FF00FF">不小于</font>6;此时给(5,10)加上间隙锁并停止扫描.  

4.唯一索引范围查询-小于等于(<=)-目标记录不在表中  
`select * from table where id < 6 for update`  
**注意:** 此时你会发现,貌似第3点加锁的策略完全适用于当前场景的加锁策略.  
**结论:** <font color="#00FF00">唯一索引范围查询,只要目标记录不在表中;不管是小于还是小于等于查询,除了最后一个Next-Key Lock会退化为间隙锁之外,别的锁依旧都是Next-Key Lock</font>

5.唯一索引范围查询-小于(<)-目标记录在表中  
`select * from table where id < 5 for update`  
**查询结果:** 查询到记录1;并且记录5在表中  
* 从-∞开始往右扫描,扫描到的第一条记录为1;并且1小于6;此时给(-∞,1]加上Next-Key Lock 
* 从1开始往右扫描,扫描的第一条记录为5;但是5<font color="#FF00FF">不小于</font>6;此时给(1,5)加上间隙锁  

**发现:** <font color="#00FF00">唯一索引范围查询-小于(<)-目标记录不在表中、唯一索引范围查询-小于(<)-目标记录在表中、唯一索引范围查询-小于等于(<=)-目标记录不在表中.好像都一样!都是最后一个Next-Key Lock退化为间隙锁.  </font>

6.唯一索引范围查询-小于等于(<=)-目标记录在表中  
`select * from table where id <= 5 for update`  
**查询结果:** 查询到记录1和记录5  
* 从-∞开始往右扫描,扫描到的第一条记录为1;此时给(-∞,1]加上Next-Key Lock  
* 从1开始往右扫描,扫描到的第一条记录为5;此时给(1,5]加上Next-Key Lock  
* 扫描结束(在这种情况下并不会继续向右扫描)  

#### 3.4.5 非唯一索引等值查询
**注意:** 当使用非唯一索引(二级索引)查询的时候,会先对二级索引加锁,如果满足查询条件才会对唯一索引加锁.  

1.非唯一索引等值查询-目标记录不在表中  
`select * from table where age = 25 for update`  
利用二级索引进行查询时会先将二级索引的字段进行排序,所以依照上面的表格,现在字段的顺序为:  
|  id   |  name  |  age  |
| :---: | :----: | :---: |
|   1   | 蔡徐坤 |  19   |
|  15   | 黄明昊 |  20   |
|   5   | 马嘉祺 |  21   |
|  10   | 林彦俊 |  22   |
|  20   | 张真源 |  39   |
* 同样和唯一索引等值查询-目标记录不在表中一样;此时会给age索引在(22,39)加上间隙锁  

**分析:** 此时如果其它的事务插入age值在[23-38]范围内的数据会发生阻塞.  
> 在什么情况下其它事务可以在age为22或39时插入数据;什么情况下又会阻塞?  

**关键:** 二级索引是按照索引值(age)进行顺序存放的,在相同的二级索引下值情况下,会再按照主键id顺序存放.  
* 当插入age=22,并且id>10时;会发生阻塞  
* 当插入age=22,并且id<10时;会插入成功
* 当插入age=39,并且id<20时;会发生阻塞
* 当插入age=39,并且id>20时;会插入成功  

**结论:** 实际上只要插入的记录在间隙锁<font color="#FF00FF">(22,39)</font>中间,那么就会发生阻塞;否则可以正常插入.  

2.非唯一索引等值查询-目标记录在表中  
`select * from table where age = 22 for update`  
*这里同样给出现在表的顺序*  
|  id   |  name  |  age  |
| :---: | :----: | :---: |
|   1   | 蔡徐坤 |  19   |
|  15   | 黄明昊 |  20   |
|   5   | 马嘉祺 |  21   |
|  10   | 林彦俊 |  22   |
|  20   | 张真源 |  39   |

* 此时可以查询到记录age=22,所以在age索引的记录22上添加Next-Key Lock锁(21,22];由于目标记录满足查询条件,所以会对age=22的这条记录的聚簇索引加行锁-记录锁-写锁  
* 继续从记录age=22的索引向右找,找到不满足条件的记录age=39;此时会对age=39的索引加间隙锁(22,39)    

**同理:** 加上这两把锁对age=21、age=22、age=39这三种记录能否插入的分析  
* 当插入age=21,并且id<5时;会插入成功
* 当插入age=21,并且id>5时;会发生阻塞
* 当插入age=22,并且id<10时;会发生阻塞
* 当插入age=22,并且id>10时;会发生阻塞;这是由于这里有(22,39)这把间隙锁导致插入阻塞,如果没有间隙锁则会插入成功.
* 当插入age=39,并且id<20时;会发生阻塞
* 当插入age=39,并且id>20时;会插入成功

*扩展:添加(22,39)这把间隙锁的目的就是防止幻读*

#### 3.4.6 非唯一索引范围查询  
**注意:** 非唯一索引范围查询最大的特点就是,二级索引加锁只会加Next-Key Lock  
`select * from table where age >=22 for update` 记录22是存在于表中的  
* 依旧先从记录22开始查询;发现记录22存在于表中,所以此时会将记录22加上行锁-Next-Key Lock-写锁;范围是(21,22];同时对该记录对应的聚簇索引的主键10加上记录锁  
* 接着从22开始往右查询,查到的第一个记录为39;此时会在索引39加上Next-Key Lock-写锁锁住(22,39]范围的记录;同时对该记录对应的聚簇索引的主键20加上记录锁  
* 接着再从索引39往右查询,一直到+∞;此时Next-key Lock写锁锁住(39,+∞]的记录.

#### 3.4.7 没有加索引的查询  
1.再次提醒必须是当前读、可重复读的隔离级别  

如果当前读的查询条件没有使用索引列进行查询,或者查询语句没有走索引,那么将会导致全表扫描,此时相当于对每一条记录都加上Next-Key Lock锁,此时相当于锁住全表了.  
不仅是当前读,如果是delete、update语句没有使用索引;同样也会导致对每一条记录加Next-Key Lock.  
<font color="#00FF00">在线上在执行update、delete、select ... for update等具有加锁性质的语句,一定要检查语句是否走了索引,如果是全表扫描的话,会对每一个索引加next-key锁,相当于把整个表锁住了,这是挺严重的问题</font>

2.避免update或delete没用索引导致全表索引加锁  
*提示:update或delete不使用索引导致全表扫描并不是会发生表锁,而是将索引的每个记录加Next-Key Lock;只不过效果等同于加表锁*  

可以将MySQL中的sql_safe_updates参数设置为1,开启安全更新模式;从而来避免update、delete给全索引加锁.  
`SET sql_safe_updates = [0|1];` 开启安全更新模式  

当sql_safe_updates设置为1时  
update语句必须满足如下条件之一才能执行成功:  
* 使用where,并且where条件中必须有索引列  
* 使用limit  
* 同时使用where和limit,此时where条件中可以没有索引列  

delete语句必须满足以下条件能执行成功:
* 同时使用where和limit,此时where条件中可以没有索引列

## 5.索引
**目录:**  
5.x 查询执行计划  



### 5.x 查询执行计划  



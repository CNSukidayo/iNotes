# 目录  
1.Java内存区域  
2.JVM垃圾回收  




## 1.Java内存区域
**目录:**  
1.1 运行时数据区域  
1.2 程序计数器  
1.3 虚拟机栈  
1.4 本地方法栈  
1.5 堆  
1.6 元空间  
1.7 运行时常量池  
1.8 字符串常量池  
1.9 直接内存  
1.10 对象的创建  
1.11 对象的内存布局  
1.12 对象的访问定位    


### 1.1 运行时数据区域
![运行时数据区区域](resources/JVM-simple/1.png)  
从上图可以看出,JVM的内存主要由`运行时数据区域`+`本地内存`两个部分构成  
其中按照<font color="#00FF00">线程间是否共享</font>又可以做如下划分:  
**线程私有:**  
* 虚拟机栈  
* 本地方法栈
* 程序计数器  

**线程共享的:**  
* 堆
* 本地内存

### 1.2 程序计数器
<font color="#00FF00">线程私有的</font>,程序计数器是一块较小的内存空间;可以看作是字节码运行行号的指示器;主要作用也类似于CPU运行时的程序计数器,即用于指向下一条字节码指令的地址.  
正如操作系统中的线程一样,为了保证线程上下文切换后能回到原来的位置继续执行,需要将程序计数器内存保存在寄存器中;即每个线程都需要有一个独立的程序计数器.各线程之间计数器互不影响,独立存储  

*注意:程序计数器是唯一一个不会出现`OutOfMemoryError`的内存区域,它的生命周期随着线程的创建而创建,随着线程的结束而死亡*

### 1.3 虚拟机栈
<font color="#00FF00">线程私有的</font>,除了Java中native方法是通过本地方法栈实现的,其它所有的Java方法调用都是通过虚拟机栈来实现的.  
方法调用的数据需要通过栈进行传递,<font color="#00FF00">每一次方法调用都会有一个对应的栈帧被压入栈中,每一个方法调用结束后,都会有一个栈帧被弹出</font>  
栈由一个个<font color="#FF00FF">栈帧</font>组成,而每个栈帧中都拥有:局部变量表、操作数栈、动态链接、方法返回地址;和数据结构上的栈类似,两者都是先进后出的数据结构,只支持出栈和入栈两种操作  
**<font color="#FF00FF">一个方法调用对应一个栈帧</font>**

![虚拟机栈](resources/JVM-simple/2.png)  

1.局部变量表  
主要存放了编译期可知的各种数据类型boolean、byte、char、short、int、float、long、double、对象引用(reference类型,它不同于对象本身,可能是一个指向对象起始地址的引用指针,也可能是指向一个代表对象的句柄或其他与此对象相关的位置)  
![局部变量表](resources/JVM-simple/3.png)  

2.操作数栈  
主要作为方法调用的中转站使用,用于存放方法执行过程中产生的中间计算结果.另外,计算过程中产生的临时变量也会放在操作数栈中  

3.动态链接  
主要服务一个方法需要调用其他方法的场景.Class文件的常量池里保存有大量的符号引用比如方法引用的符号引用.当一个方法要调用其他方法,需要将常量池中指向方法的符号引用转化为其在内存地址中的<font color="#00FF00">直接引用</font>.动态链接的作用就是为了将符号引用转换为调用方法的直接引用,这个过程也被称为**动态连接**  
![动态链接](resources/JVM-simple/4.png)  
栈空间不是无限的,如果函数调用陷入无限循环的话,就会导致栈中被压入太多栈帧而占用太多空间,导致栈空间过深;那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候,就会抛出`StackOverFlowError`错误  

Java方法有两种返回方式,一种是`return`语句正常返回,一种是`抛出异常`.不管哪种返回方式,<font color="#00FF00">都会导致栈帧被弹出</font>.也就是说,栈帧随着方法调用而创建,随着方法结束而销毁.无论方法正常完成还是异常完成都算作方法结束  
除了`StackOverFlowError`错误之外,栈还可能会出现`OutOfMemoryError`错误,这是因为栈的内存大小可以动态扩展,如果虚拟机在动态扩展栈时无法申请得到足够的空间内存,则抛出`OutOfMemoryError`异常  

总结程序运行中栈可能会出现两种错误:  
* StackOverFlowError:若栈的内存大小不允许动态扩展,那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候,就抛出`StackOverFlowError`错误
* OutOfMemoryError:如果栈的内存大小可以动态扩展,如果虚拟机在动态扩展栈时无法申请到足够的内存空间,则抛出`OutOfMemoryError`异常  

### 1.4 本地方法栈
**介绍:**  
和虚拟机栈所发挥的作用非常相似,区别是:**虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚拟机使用到的Native方法服务**  
本地方法被执行的时候,在本地方法栈也会创建一个栈帧,用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息  
方法执行完毕后相应的栈帧也会出栈并释放内存空间,也会出现`StackOverFlowError`和`OutOfMemoryError`两种错误  


### 1.5 堆
<font color="#00FF00">线程共享</font>**此内存区域的唯一目的就是存放对象实例**  
Java堆是垃圾收集器管理的主要区域,因此也被称为GC堆,从垃圾回收的角度,由于现在收集器基本都采用分代垃圾收集算法,所以堆还可以细分为<font color="#00FF00">新生代和老年代</font>,再细分还可以分为Eden、Survivor、Old等空间,进一步划分的目的是更好地回收内存,或者更快地分配内存.  
堆内存通常分为以下三个部分:  
* 新生代
* 老年代
* 永久代(元空间)


下图所示的Eden区、两个Survivor区S0和S1都属于新生代,中间一层属于老年代,最下面一层属于永久代(元空间)  
![堆内存](resources/JVM-simple/5.png)  
**JDK8版本之后PermGen(永久代)已被 Metaspace(元空间)取代,元空间使用的是本地内存**  
大部分情况,对象都会首先在Eden区域分配(在Eden区域分配的对象的年龄默认是0),在一次新生代垃圾回收后,如果对象还存活,则会进入S0或者S1,并且对象的年龄还会加1(Eden区->Survivor区后对象的初始年龄变为1),当它的年龄增加到一定程度(默认为15岁),就会被晋升到老年代中.对象晋升到老年代的年龄阈值,可以通过参数`-XX:MaxTenuringThreshold`来设置  
<font color="#00FF00">实际上新生代晋升老年代的阈值是动态产生的:</font>  
Hotspot会遍历所有的对象,按照年龄从小到大对其占用的大小进行累积,当累积的某个年龄在survivor区占用的内存大小超过该区域内存的一半时;取这个年龄和`MaxTenuringThreshold`中更小的一个值,作为新的晋升年龄阈值  

### 1.6 元空间
元空间隶属于本地内存,所以是<font color="#00FF00">线程共享</font>  
元空间会存储已被虚拟机加载的**类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存**等数据  

1.元空间使用的是本地内存,受到本机可用内存的限制;可以使用`-XX:MaxMetaspaceSize`参数来设置元空间大小,默认值为unlimited;意味着它只受系统内存限制,元空间会在运行时根据应用程序需求动态地重新调整大小.  

2.元空间里面存放的是类的元数据,这样加载多少类的元数据就不由MaxPermSize控制了,而由系统的实际可用空间来控制,这样能加载的类就更多了  

3.一些相关的参数设置  
```java
-XX:MetaspaceSize=N     //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```

### 1.7 运行时常量池
运行时常量池隶属于元空间,所以是<font color="#00FF00">线程共享</font>  
Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有用于存放编译期生成的各种字面量(Literal)和符号引用(Symbolic Reference)的常量池表(Constant Pool Table)  
字面量是源代码中的固定值的表示法,即通过字面我们就能知道其值的含义.字面量包括整数、浮点数和字符串字面量.常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号  

### 1.8 字符串常量池
字符串常量池隶属于堆,所以是<font color="#00FF00">线程共享</font>  
字符串常量池是JVM为了提升性能和减少内存消耗针对<font color="#00FF00">字符串</font>(String 类)专门开辟的一块区域,主要目的是为了**避免字符串的重复创建**  

### 1.9 直接内存
直接内存是一种特殊的内存缓冲区,并不在Java堆或方法区中分配的,而是通过JNI的方式在本地内存上分配的  
直接内存受操作系统管理(而不是虚拟机),这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响  

### 1.10 对象的创建
对象的创建分为5步  

1.类加载检查  
虚拟机遇到一条new指令时,首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用,并且检查这个符号引用代表的类是否已被加载过、解析和初始化过.如果没有,那必须<font color="#00FF00">先执行相应的类加载过程</font>  

2.分配内存  
在类加载检查通过后,接下来虚拟机将为新生对象**分配内存**.<font color="#00FF00">对象所需的内存大小在类加载完成后便可确定</font>,为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来.分配方式有`指针碰撞`和`空闲列表`两种,选择哪种分配方式由Java堆是否规整决定,而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定  

**内存分配的两种方式**  
* 指针碰撞:  
  * 适用场合:堆内存规整(即没有内存碎片)的情况下
  * 原理:用过的内存全部整合到一边,没有用过的内存放在另一边,中间有一个分界指针,只需要沿着没用过的内存方向<font color="#00FF00">将该指针移动对象内存大小位置即可</font><font color="#FF00FF">效果类似操作系统的紧凑</font>
  * 使用该分配方式的GC收集器:Serial、ParNew
* 空闲列表:
  * 适用场合:堆内存不规整的情况下
  * 原理:虚拟机会维护一个列表,该列表中会记录哪些内存块是可用的,在分配的时候,找一块儿足够大的内存块儿来划分给对象实例,最后更新列表记录<font color="#FF00FF">效果类似操作系统的分区描述表</font>
  * 使用该分配方式的GC收集器:CMS

选择以上两种方式中的哪一种,取决于Java堆内存是否规整.而Java堆内存是否规整,取决于GC 收集器的算法是`标记-清除`,还是`标记-整理`,值得注意的是,`复制算法`内存也是规整的  

**内存分配并发问题**  
在创建对象的时候有一个很重要的问题,就是线程安全,因为在实际开发过程中,创建对象是很频繁的事情,作为虚拟机来说,必须要保证线程是安全的,通常来讲,虚拟机采用两种方式来保证线程安全:  
* CAS+失败重试:CAS是乐观锁的一种实现方式.所谓乐观锁就是,每次不加锁而是假设没有冲突而去完成某项操作,如果因为冲突失败就重试,直到成功为止.虚拟机采用CAS配上失败重试的方式保证更新操作的原子性.
* TLAB:为每一个线程预先在Eden区分配一块儿内存,JVM在给线程中的对象分配内存时,首先在TLAB分配,当对象大于TLAB中的剩余内存或TLAB的内存已用尽时,再采用上述的CAS进行内存分配

关于内存分配的详细内容见:2.JVM垃圾回收=>2.1内存分配和回收原则

3.初始化零值  
内存分配完成后,虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头),这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用,程序能访问到这些字段的数据类型所对应的零值  

4.设置对象头  
初始化零值完成之后,虚拟机要对对象进行必要的设置,例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息.这些信息存放在对象头中.另外,根据虚拟机当前运行状态的不同,如是否启用偏向锁等,对象头会有不同的设置方式  

5.执行init方法  
在上面工作都完成之后,从虚拟机的视角来看,一个新的对象已经产生了,但从Java程序的视角来看,对象创建才刚开始,`init`方法还没有执行,所有的字段都还为零.所以一般来说,执行new指令之后会接着执行`init`方法,把对象按照程序员的意愿进行初始化,这样一个真正可用的对象才算完全产生出来.  

### 1.11 对象的内存布局
在Hotspot虚拟机中,对象在内存中的布局可以分为3块区域:**对象头、实例数据、对齐填充**  

Hotspot虚拟机的<font color="#00FF00">对象头</font>包括两部分信息:  
第一部分用于存储对象自身的运行时数据(哈希码、GC 分代年龄、锁状态标志等等)  
第二部分是类型指针-即对象指向它的类元数据的指针,虚拟机通过这个指针来确定这个对象是哪个类的实例  

<font color="#00FF00">实例数据</font>部分是对象真正存储的有效信息  

<font color="#00FF00">对齐填充</font>部分,因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍;当当对象<font color="#00FF00">实例数据</font>部分没有对齐时,就需要通过对齐填充来补全  

### 1.12 对象的访问定位
Java程序通过栈上的<font color="#00FF00">reference数据</font>来操作堆上的具体对象.对象的访问方式由虚拟机实现而定,目前主流的访问方式有:`使用句柄`、`直接指针`  

1.句柄  
如果使用句柄的话,那么Java堆中将会划分出一块内存来作为句柄池,reference中存储的就是对象的句柄地址,而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息  

2.直接指针  
如果使用直接指针访问,reference中存储的直接就是对象的地址  


## 2.JVM垃圾回收
**目录:**  
2.1 内存分配和回收原则  

### 2.1 内存分配和回收原则
由于现在收集器基本都采用分代垃圾收集算法,所以Java堆被划分为了几个不同的区域,这样我们就可以根据各个区域的特点选择合适的垃圾收集算法  
![堆内存](resources/JVM-simple/5.png)  

1.对象优先在Eden区分配  
大多数情况下,对象在新生代中Eden区分配.当Eden区没有足够空间进行分配时,虚拟机将发起一次<font color="#00FF00">Minor GC</font>  
当Eden区没有足够空间进行分配时,虚拟机将发起一次Minor GC.GC期间虚拟机又发现,如果S0或者S1这两个区域无法放入对象,所以只好通过<font color="#00FF00">分配担保机制</font>把新生代的对象提前转移到老年代中去,因为老年代足够放入对象,所以不会出现Full GC.执行Minor GC后,后面分配的对象如果能够存在Eden区的话,还是会在Eden区分配内存.  

**分配担保机制**  
空间分配担保是为了确保在Minor GC之前老年代本身还有容纳新生代所有对象的剩余空间  
JDK 6 Update 24 之前,在发生Minor GC之前,虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间,如果这个条件成立,那这一次Minor GC可以确保是安全的.如果不成立,则虚拟机会先查看`-XX:HandlePromotionFailure`参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许,那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小,如果大于,将尝试进行一次Minor GC,尽管这次Minor GC是有风险的;如果小于,或者`-XX: HandlePromotionFailure`设置不允许冒险,那这时就要改为进行一次Full GC.JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小,就会进行Minor GC,否则将进行 Full GC.


2.大对象直接进入老年代  
大对象就是需要大量连续内存空间的对象(比如:字符串、数组)  
大对象直接进入老年代的行为是由虚拟机动态决定的,它与具体使用的垃圾回收器和相关参数有关.大对象直接进入老年代是一种优化策略,<font color="#00FF00">旨在避免将大对象放入新生代,从而减少新生代的垃圾回收频率和成本.</font>  
* G1垃圾回收器会根据`-XX:G1HeapRegionSize`参数设置的堆区域大小和`-XX:G1MixedGCLiveThresholdPercent`参数设置的阈值,来决定哪些对象会直接进入老年代  
* Parallel Scavenge垃圾回收器中,默认情况下,并没有一个固定的阈值(`XX:ThresholdTolerance`是动态调整的)来决定何时直接在老年代分配大对象.而是由虚拟机根据当前的堆内存情况和历史数据动态决定  

3.长期存活的对象将进入老年代  
jvm虚拟机在每一个对象头信息中都设置了该对象年龄(age),通过这个年龄(age)JVM就能够判断出这个对象是存放于新生代还是老年代.  
大部分情况,对象都会**首先**在Eden区域分配.<font color="#00FF00">如果对象在Eden出生并经过第一次Minor GC后仍然能够存活,并且能被Survivor(Survivor是S0和S1的总称)容纳的话,将被移动到Survivor空间(s0或者s1)中</font>,并将对象年龄设为1(Eden区->Survivor区后对象的初始年龄变为1)  

对象在Survivor中每熬过一次<font color="#00FF00">MinorGC</font>,年龄就增加1岁,当它的年龄增加到一定程度(默认为15岁),就会被晋升到老年代中.对象晋升到老年代的年龄阈值,可以通过参数`-XX:MaxTenuringThreshold`来设置.  
<font color="#00FF00">实际上新生代晋升老年代的阈值是动态产生的:</font>  
Hotspot会遍历所有的对象,按照年龄从小到大对其占用的大小进行累积,当累积的某个年龄在survivor区占用的内存大小超过该区域内存的一半时;取这个年龄和`MaxTenuringThreshold`中更小的一个值,作为新的晋升年龄阈值  

4.GC分类  
针对HotSpot VM的实现,它里面的GC其实准确分类只有两大种:部分收集(Partial GC)、整堆收集(Full GC)  

部分收集(Partial GC):  
* 新生代收集(Minor GC / Young GC):只对新生代进行垃圾收集
* 老年代收集(Major GC / Old GC):只对老年代进行垃圾收集.需要注意的是Major GC在有的语境中也用于指代整堆收集
* 混合收集(Mixed GC):对整个新生代和<font color="#00FF00">部分</font>老年代进行垃圾收集  

整堆收集(Full GC):收集整个Java堆和元空间  


